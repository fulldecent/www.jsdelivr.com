<link rel="ractive" href="../r-page.html">
<link rel="ractive" href="../components/header.html" name="c-header">
<link rel="ractive" href="../components/footer.html" name="c-footer">
<link rel="ractive" href="../components/cdn-oss-hosting-info.html" name="c-cdn-oss-hosting-info">
<link rel="ractive" href="../components/cdn-oss-head.html" name="c-cdn-oss-head">
<link rel="ractive" href="../components/new-infographic-banner.html" name="c-new-infographic-banner">
<link rel="ractive" href="../components/request-bandwidth-stats.html" name="c-request-bandwidth-stats">

<r-page noYield="{{noYield}}" title="{{title}}" description="{{description}}">
	<c-header></c-header>

	<div class="p-custom-cdn-oss-project">
		<div class="content-wrapper">
			<c-cdn-oss-head name="{{name}}"
				link="{{projectLink}}"
				title="{{projectTitle}}"
				descr="{{projectDescr}}"
				imgW="{{projectImgW}}"
				imgH="{{projectImgH}}">
				{{#partial title}}
					{{title}}
				{{/partial}}

				{{#partial descr}}
					{{descr}}
				{{/partial}}

				{{#partial img}}
					<img width="{{imgW}}" height="{{imgH}}" src="{{@shared.assetsHost}}/img/custom-cdn-oss/{{name}}.svg">
				{{/partial}}
			</c-cdn-oss-head>

			<div class="divider"></div>

			<div class="ctrls-block">
				<div class="ctrls-block-title">Statistics</div>
				<div class="ctrls-block-ctrls">
					<div class="chart-type-ctrl">
						<span>Show numbers of</span>

						<input id="chart-switch"
							type="checkbox"
							class="chart-type-switch {{#if showChartBandwidth}}checked{{/if}}"
							twoway="false">

						<label for="chart-switch" on-click="@this.set('showChartBandwidth', !showChartBandwidth)">
							<span>Request</span>
							<span>GB</span>
							<div class="slide-select">
								<div class="selected"></div>
							</div>
						</label>
					</div>

					<div class="data-range-ctrl">
						<span>Data range:</span>

						<div class="btn-group">
							<button type="button" class="btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
								<span>{{~/statsPeriods[statsPeriod]}}</span>
								<i class="fa fa-angle-down" aria-hidden="true"></i>
							</button>

							<ul class="dropdown-menu">
								{{#each ~/statsPeriods}}
									<li><a on-click="@this.set('statsPeriod', @key)">{{this}}</a></li>
								{{/each}}
							</ul>
						</div>
					</div>
				</div>
			</div>

			<c-request-bandwidth-stats name="{{name}}" period="{{statsPeriods[statsPeriod]}}"></c-request-bandwidth-stats>

			{{#if noPackageStatsData}}
				<div class="no-data-wrapper">
					<img width="180" height="152" src="{{@shared.assetsHost}}/img/no-data-chart-main.svg">
					<span>No statistics yet</span>
					<span>This is probably not a very popular package :(</span>
				</div>
			{{else}}
				<div class="chart-ctrls">
					<div class="chart-ctrls-title">Stats for last {{~/statsPeriods[statsPeriod]}}</div>
					<div class="chart-ctrls-group-by">
						<span>
							Group by:
						</span>

						<div class="btn-group">
							<button type="button" class="btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
								<span>{{~/usageChartGroupByValues[usageChartGroupBy].value}}</span>
								<i class="fa fa-angle-down" aria-hidden="true"></i>
							</button>

							<ul class="dropdown-menu">
								{{#each ~/usageChartGroupByValues}}
									<li>
										{{#if this.isAvailable}}
											<a on-click="@this.set('usageChartGroupBy', @key)">{{this.value}}</a>
										{{/if}}
									</li>
								{{/each}}
							</ul>
						</div>
					</div>
				</div>

				<div class="chart-wrapper">
					<canvas id="cdn-stats-chart"></canvas>
				</div>
			{{/if}}

			<c-new-infographic-banner>
				{{#partial text}}
					Learn more about<br />
					the infrastructure that<br />
					powers <a href="/network/infographic" target="_blank" class="router-ignore">jsDelivr</a>
				{{/partial}}
			</c-new-infographic-banner>

			<c-cdn-oss-hosting-info></c-cdn-oss-hosting-info>
		</div>
	</div>

	<c-footer></c-footer>
</r-page>

<script>
	const _ = require('../../public/js/_');
	const http = require('../../public/js/utils/http');
	const createBarChart = require('../../public/js/utils/create-bar-chart');

	component.exports = {
		computed: {
			title () {
				return this.get('projectTitle') ? this.get('projectTitle') + ' - jsDelivr' : ' jsDelivr';
			},
		},
		data () {
			return {
				description: 'TODO',
				statsPeriods: {
					1: 'day',
					7: 'week',
					30: 'month',
					365: 'year',
				},
				statsPeriod: '30',
				showChartBandwidth: false,
				usageChartGroupByValues: {
					day: { value: 'day', isAvailable: true },
					week: { value: 'week', isAvailable: true },
					// since default statsPeriod is 30 (month) - group by month not available initially
					month: { value: 'month', isAvailable: false },
				},
				usageChartGroupBy: 'day',
				noPackageStatsData: false,
				projectsData: {
					cocoa: {
						title: 'CocoaPods',
						descr: 'CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 87 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.',
						link: 'www.cocoapods.org',
						imgW: '202',
						imgH: '46',
					},
					pyodide: {
						title: 'Pyodide',
						descr: 'Pyodide brings the Python 3.9 runtime to the browser via WebAssembly, thanks to Emscripten. It builds the Python scientific stack including NumPy, Pandas, Matplotlib, SciPy, and scikit-learn. Over 75 packages are currently available. In addition, it’s possible to install pure Python wheels from PyPI.',
						link: 'pyodide.org',
						imgW: '170',
						imgH: '56',
					},
					musescore: {
						title: 'MuseScore',
						descr: 'Create, play and print beautiful sheet music. The world’s most popular notation software.',
						link: 'musescore.org',
						imgW: '213',
						imgH: '48',
					},
				},
				projectTitle: '',
				projectDescr: '',
				projectImgW: '',
				projectImgH: '',
				rawStatsData: {},
				preparedStatsData: {},
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				this.observe('name', (name) => {
					let projectsData = this.get('projectsData');

					this.set('projectTitle', projectsData[name].title);
					this.set('projectDescr', projectsData[name].descr);
					this.set('projectImgW', projectsData[name].imgW);
					this.set('projectImgH', projectsData[name].imgH);
					this.set('projectLink', projectsData[name].link);
				});

				// handle chart period changes by updating groupBy options and chart data fetching
				this.observe('statsPeriod', (newStatsPeriod, prevStatsPeriod) => {
					let period = this.get('statsPeriods')[newStatsPeriod];
					let name = this.get('name');

					// once chart period is changed - update groupBy options respectively to period
					switch (period) {
						case 'year':
							this.set('usageChartGroupByValues', {
								day: { value: 'day', isAvailable: true },
								week: { value: 'week', isAvailable: true },
								month: { value: 'month', isAvailable: true },
							});
							break;
						case 'month':
							this.set('usageChartGroupByValues', {
								day: { value: 'day', isAvailable: true },
								week: { value: 'week', isAvailable: true },
								month: { value: 'month', isAvailable: false },
							});
							break;
						case 'week':
							this.set('usageChartGroupByValues', {
								day: { value: 'day', isAvailable: true },
								week: { value: 'week', isAvailable: false },
								month: { value: 'month', isAvailable: false },
							});
							break;
					}

					// prevent chart data fetching from the back when period is DAY, left it as it was prev
					if (period === 'day') { return }

					http.fetchCdnOssStats(name, period).then((response) => {
						if (!response.hits.total || !response.bandwidth.total) {
							this.set('noPackageStatsData', true);
							return;
						}

						this.set('noPackageStatsData', false);
						// once new data fetched we should set groupBy to default value before raw data set
						this.set('usageChartGroupBy', 'day');
						this.set('rawStatsData', response);
					});
				});

				// handle raw data and prepare it for chart
				this.observe('rawStatsData showChartBandwidth usageChartGroupBy', () => {
					let rawStatsData = this.get('rawStatsData');
					let chartPeriod = this.get('statsPeriods')[this.get('statsPeriod')];
					let showChartBandwidth = this.get('showChartBandwidth');
					let dataType = showChartBandwidth ? 'bandwidth' : 'hits';
					let convertionFactor = 1;
					let groupBy = { day: 1, week: 7, month: 30, year: 365 };
					let groupedDayCount = groupBy[this.get('usageChartGroupBy')];
					let valuesByDateArr = [];
					let dataGroupedByPeriod = [];
					let xAxisDates = [];

					let countDay = 0;
					let tempData = 0;

					// if we are showing bandwidth instead of requests we should change convertionFactor for conversion to GB's
					if (showChartBandwidth) {
						convertionFactor = 1e9;
					}

					// group data by value per date
					Object.keys(rawStatsData[dataType].dates).forEach((date) => {
						valuesByDateArr.push([ date, rawStatsData[dataType].dates[date] ]);
					});

					// collect X-Axis dates relatively to groupBy period
					valuesByDateArr.forEach((value) => {
						countDay++;

						if (countDay % groupedDayCount === 0) {
							countDay = 0;
							xAxisDates.push(value[0]);
						}
					});

					countDay = 0;

					//group data by groupBy period
					Object.keys(rawStatsData[dataType].dates).forEach((date) => {
						countDay++;
						tempData += rawStatsData[dataType].dates[date];

						if (countDay >= groupedDayCount) {
							dataGroupedByPeriod.push(Math.round(tempData / convertionFactor));
							countDay = 0;
							tempData = 0;
						}
					});

					let labels = _.getChartXAxisData(xAxisDates, chartPeriod);
					let minRangeValue = _.getValueByMagnitude(Math.min(...dataGroupedByPeriod), 'floor');
					let maxRangeValue = _.getValueByMagnitude(Math.max(...dataGroupedByPeriod), 'ceil', 1);

					// set prepared data for chart
					this.set('preparedStatsData', {
						data: dataGroupedByPeriod,
						labels,
						xAxisDates,
						minRangeValue,
						maxRangeValue,
						showChartBandwidth,
						chartPeriod,
					});
				}, { init: false });
			}
		},
		onrender () {
			let statsChart;

			// draw a chart when data is ready
			this.observe('preparedStatsData', (preparedStatsData) => {
				let { labels, xAxisDates, minRangeValue, maxRangeValue, data, showChartBandwidth, chartPeriod } = preparedStatsData;
				let statsChartCanvasEl = this.find('#cdn-stats-chart');

				if (!preparedStatsData || !statsChartCanvasEl) { return; }

				if (statsChart) {
					statsChart.destroy();
					statsChart = null;
				}

				let chartData = {
					labels,
					datasets: [{
						data,
						borderWidth: 0,
						barThickness: chartPeriod === 'year' ? 2 : 10,
						hoverBackgroundColor: '#F65128',
					}],
				};
				let chartSettings = {
					useYAxisBorderPlugin: !(_.isMobileScreen() || _.isTabletScreen()),
					useExternalTooltip: true,
					externalTooltipVerticalOffset: 40,
				};
				let chartConfig = {
					options: {
						scales: {
							x: {
								display: true,
								ticks: {
									autoSkip: false,
									color: '#5C667A',
									font: {
										size: 12,
										family: 'Lexend, sans-serif',
										lineHeight: 2,
									},
									callback (tickIdx) {
										let labelValue = this.getLabelForValue(tickIdx);
										let day = Array.isArray(labelValue) ? labelValue[0].split('-').slice(-1)[0] : labelValue.split('-').slice(-1)[0];

										if (chartPeriod === 'year') {
											if (labelValue[2]) {
												if (_.isMobileScreen()) { return [ `${labelValue[2]} ${labelValue[1]}` ]; }

												return [ labelValue[1], labelValue[2] ];
											}

											if (labelValue[1] && !_.isMobileScreen()) { return [ labelValue[1] ]; }

											return;
										}

										if (Array.isArray(labelValue) && labelValue[1]) {
											return [ day, labelValue[1] ];
										}

										if (chartPeriod === 'month' && _.isMobileScreen()) { return; }

										return [ day ];
									},
								},
								grid: {
									display: false,
									drawBorder: false,
								},
							},
							y: {
								display: true,
								min: minRangeValue,
								max: maxRangeValue,
								ticks: {
									count: 8,
									color: '#5C667A',
									crossAlign: 'far',
									font: {
										size: 12,
										family: 'Lexend, sans-serif',
									},
									callback (tickIdx) {
										let labelValue = this.getLabelForValue(tickIdx);
										let valueByMagnitude = _.getValueByMagnitude(Math.round(labelValue.replace(/,/g, '')), 'round', 1, false);

										if (_.isMobileScreen()) {
											return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} GB` : _.autoConvertBytesToUnits(valueByMagnitude);
										}

										return showChartBandwidth ? `${_.formatNumber(valueByMagnitude)} GB` : _.formatNumber(valueByMagnitude);
									},
								},
								grid: {
									display: false,
									drawBorder: false,
								},
							},
						},
					},
				};

				statsChart = createBarChart(statsChartCanvasEl, chartData, chartSettings, chartConfig);
			}, { init : false });
		},
	};
</script>
