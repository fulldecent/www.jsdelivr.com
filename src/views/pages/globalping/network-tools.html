<link rel="ractive" href="../../r-page-globalping.html" name="r-page">
<link rel="ractive" href="../../components/header.html" name="c-header">
<link rel="ractive" href="../../components/footer.html" name="c-footer">
<link rel="ractive" href="../../components/notification.html" name="c-notification">
<link rel="ractive" href="../../components/controlled-input.html" name="c-controlled-input">
<link rel="ractive" href="../../components/gp-test-results.html" name="c-gp-test-results">
<link rel="ractive" href="../../components/gp-top-navigation.html" name="c-gp-top-navigation">
<link rel="ractive" href="../../components/gp-jumbotron.html" name="c-gp-jumbotron">

<r-page noYield="{{noYield}}" title="{{title}}" description="{{description}}">
	<c-notification></c-notification>

	<c-header additionalClasses="header-with-globalping-bg"></c-header>

	<div class="p-globalping-network-tools">
		<c-gp-top-navigation currentName="globalping-network-tools"></c-gp-top-navigation>

		<c-gp-jumbotron className="network-tools" useAltGridImg="true"></c-gp-jumbotron>

		<div class="gp-nettools_main-info">
			{{#if locationData}}
				<h1>{{displayingTestType}} from {{#if locationData.probesCnt}}multiple locations in {{/if}}</h1>
				<span>
					{{#if locationData.name}}{{locationData.name}}, {{/if}}
					<a target="_blank" rel="noopener noreferrer" href="{{highLevelLocationHref}}" class="gp-nettools_green-text">{{locationData.from}}</a>
				</span>

				<div class="gp-nettools_main-info_input-block">
					<span>Run a Free</span>

					<div class="gp_dropdown_alt">
						<div class="btn-group">
							<button type="button"
								class="dropdown-toggle"
								data-toggle="dropdown"
								aria-haspopup="true"
								aria-expanded="false">
								<span>{{~/displayingTestType}}</span>
								<i class="fa fa-angle-down" aria-hidden="true"></i>
							</button>

							<div class="dropdown-menu">
								{{#each ~/testTypesList}}
									{{#if this.toDisplay !== displayingTestType}}
										<div on-click="@this.handleTestTypeSelect(this.name)">{{this.toDisplay}}</div>
									{{/if}}
								{{/each}}
							</div>
						</div>
					</div>

					<span>test</span>
				</div>
			{{/if}}
		</div>

		<div class="gp-nettools_demo-tools">
			<div class="gp-nettools_demo-tools_head">
				<span></span>
				<span></span>
				<span></span>
			</div>

			<div class="gp-nettools_demo-tools_ctrls">
				<c-controlled-input
					id="targetInput"
					value="{{testOpts.target}}"
					error="{{inputErrors.target}}"
					placeholder="IP or host"
					labelText="Target"
					classList="gp-nettools_demo-tools_ctrls_target gp_input">
				</c-controlled-input>

				<c-controlled-input
					id="limitInput"
					value="{{testOpts.limit}}"
					error="{{inputErrors.limit}}"
					placeholder="{{defaultTestLimit}}"
					labelText="Probes"
					classList="gp-nettools_demo-tools_ctrls_probes gp_input">
				</c-controlled-input>

				<button on-click="@this.proceedToTest()"
					class="gp-nettools_demo-tools_ctrls_btn gp_btn_green {{#if testInProgress}}gp_btn_green_disabled gp_btn_green_loading{{/if}}"
					disabled="{{testInProgress}}">
					{{#if testInProgress}}
						<div></div>
						<div></div>
						<div></div>
						<div></div>
					{{else}}
						Run {{btnTestType}} Test
					{{/if}}
				</button>
			</div>

			{{#if testFailed}}
				<div class="gp_map-block_demo-tools_fail-msg">
					<img width="56"
						height="56"
						src="{{@shared.assetsHost}}/img/globalping/fail-icon-big.svg">

					<p>
						All tests failed. Maybe you specified a non existing endpoint?
					</p>
				</div>
			{{elseif testResults}}
				<c-gp-test-results
					testReqParams="{{testReqParams}}"
					testResults="{{testResults}}"
					testInProgress="{{testInProgress}}">
				</c-gp-test-results>
			{{else}}
				<div class="gp-nettools_demo-tools_descr">
					<img width="56"
						height="56"
						src="{{@shared.assetsHost}}/img/globalping/bulb-icon.svg">
					<span>Run a global ping latency test to debug and troubleshoot your network, CDN or website from multiple locations in Europe.</span>
				</div>
			{{/if}}
		</div>

		<div class="gp-nettools_learn-how">
			<span class="gp-nettools_learn-how_title">
				Learn more about how Globalping makes global network tests and benchmarking possible and free for all.
			</span>

			<span class="gp-nettools_learn-how_descr">
				Debug your web services and servers, understand and fix your routing, simply by running network commands from Europe or any other specific location like a country or city.
			</span>

			<a href="/globalping" class="gp-nettools_learn-how_btn gp_btn_green">
				Learn more
			</a>
		</div>

		<div class="gp-nettools_ping">
			<span class="gp-nettools_ping_title">
				What is ping?
			</span>

			<span class="gp-nettools_ping_descr">
				Ping is a tool that sends ICMP packets to an IP address (hostname is also accepted but will be first resolved to an IP) to understand the latency to the target or if the target server or website exist and are working. Since website and server response times are very important, Ping is a very simple way to quickly and easily check and understand the network delay in milliseconds between the sender and receiver. It's basically how long it takes for  data to travel across the internet to the destination and then back to the sender.  A low latency is always better and will result in a faster website and fewer issues. Methods to improve the latency include moving the server closer to the users, using a CDN or for advanced users improving peering and BGP routing.
			</span>
		</div>
	</div>

	<c-footer></c-footer>
</r-page>

<script>
	const _ = require('../../../assets/js/_');
	const http = require('../../../assets/js/utils/http');
	const has = require('../../../assets/js/utils/has');
	const countries = require('../../../assets/json/countries.json');
	const continents = require('../../../assets/json/continents.json');
	const usaStates = require('../../../assets/json/usa-states.json');
	const DEFAULT_LIMIT = 3;
	const INITIAL_OPTS_VALUES = {
		type: 'Ping',
		target: 'cdn.jsdelivr.net',
	};

	component.exports = {
		data () {
			return {
				_,
				title: 'Globalping - jsDelivr',
				description: 'TODO: add Globalping Network Tools description',
				selectedTestType: INITIAL_OPTS_VALUES.type,
				displayingTestType: INITIAL_OPTS_VALUES.type,
				btnTestType: INITIAL_OPTS_VALUES.type,
				testTypesList: [
					{
						name: 'Ping',
						toDisplay: 'Ping',
					},
					{
						name: 'Traceroute',
						toDisplay: 'Traceroute',
					},
					{
						name: 'DNS',
						toDisplay: 'DNS resolve',
					},
					{
						name: 'MTR',
						toDisplay: 'MTR',
					},
					{
						name: 'HTTP',
						toDisplay: 'HTTP',
					},
				],
				testOpts: {
					target: INITIAL_OPTS_VALUES.target,
					limit: '',
				},
				inputErrors: {},
				testResults: null,
				testInProgress: false,
				testReqInterval: null,
				defaultTestLimit: DEFAULT_LIMIT,
				probesResponse: null,
				locationData: null,
				totalProbesCnt: 0,
				parsedLocations: {
					cities: {},
					asns: {},
					networks: {},
					countries: {},
					continents: {},
					regions: {},
				},
				highLevelLocationHref: null,
				probesParsed: false,
				testReqParams: null,
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				this.observe('selectedTestType', (selectedTestType) => {
					if (selectedTestType) {
						switch (selectedTestType.toLowerCase()) {
							case 'mtr':
							case 'http':
								this.set('displayingTestType', selectedTestType.toUpperCase());
								this.set('btnTestType', selectedTestType.toUpperCase());

								break;

							case 'dns':
								this.set('displayingTestType', `${selectedTestType.toUpperCase()} resolve`);
								this.set('btnTestType', selectedTestType.toUpperCase());

								break;

							default:
								this.set('displayingTestType', _.capitalizeStrEveryFirstLetter(selectedTestType));
								this.set('btnTestType', _.capitalizeStrEveryFirstLetter(selectedTestType));
						}
					}

					this.set('inputErrors', {});
					this.set('testResults', null);
				});

				// get probes from sessionStorage or fetch them
				if (has.sessionStorage()) {
					let probesResponse = sessionStorage.getItem('probesResponse');

					if (probesResponse) {
						this.handleProbesResponse(true)(probesResponse);
					} else {
						http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
					}
				} else {
					http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
				}

				// handle test results in real time
				this.observe('realTimeTestResResponse', (realTimeTestResResponse) => {
					if (realTimeTestResResponse.status === 'finished') {
						clearInterval(this.get('testReqInterval'));
						this.set('testInProgress', false);
					}

					let prevTestResults = this.get('testResults') || [];
					let updTestResults = realTimeTestResResponse.results.filter((res) => {
						// if it is no in-progress then it is already finished or failed and we could draw a marker
						if (res.result.status !== 'in-progress') { return true; }

						return false;
					});

					// filter out results that have already been drawn
					let newTestResults = updTestResults.filter((updRes) => {
						return !prevTestResults.some(prevRes => JSON.stringify(prevRes) === JSON.stringify(updRes));
					});

					this.set('testResults', [ ...prevTestResults, ...newTestResults ]);
				}, { init: false });
			}
		},
		oncomplete () {
			if (!Ractive.isServer) {
				// run the test if user is pressed Enter inside of any of options inputs
				let targetInput = this.find('#targetInput');
				let limitInput = this.find('#limitInput');

				let handleEnterBtn = (event) => {
					if (event.key === 'Enter') {
						event.preventDefault();
						this.proceedToTest();
					}
				};

				targetInput.addEventListener('keypress', handleEnterBtn);
				limitInput.addEventListener('keypress', handleEnterBtn);

				// handle URL, get values from it and set locationData
				this.observe('probesParsed', (probesParsed) => {
					if (!probesParsed) { return; }

					let rawParamsValue = this.get('params');

					if (!rawParamsValue) { return; }

					let testTypesList = this.get('testTypesList');
					let clearValue = rawParamsValue.replace(/\/globalping\/network-tools\/?/, '').toLowerCase();

					if (clearValue.includes('-from-')) {
						let valueSplitted = clearValue.split('-from-');
						let testType = valueSplitted[0];
						let locationData = this.getLocDataByLocValue(valueSplitted[1]);
						let isTestTypePresents = testTypesList.some(i => i.name.toLowerCase() === testType.toLowerCase());

						// if both location and testType are correct and present
						if (locationData && isTestTypePresents) {
							this.set('selectedTestType', testType);
							this.set('locationData', locationData);
							this.set('highLevelLocationHref', `${global.location.origin}${this.modifyQueryPart(testType, locationData.fromAsUrlPart)}`);
						} else if (isTestTypePresents && !locationData) {
						// when testType correct but location incorrect or missing
							this.moveToNewPageURL(testType, null, true);
						} else if (locationData && !isTestTypePresents) {
						// when  location correct and testType is incorrect
							this.moveToNewPageURL(INITIAL_OPTS_VALUES.type);
						} else {
							// when testType is incorect and location incorrect or missing
							this.moveToNewPageURL(INITIAL_OPTS_VALUES.type, null, true);
						}
					} else {
						let testTypeData = testTypesList.find(i => i.name.toLowerCase() === clearValue);

						if (testTypeData) {
							this.set('selectedTestType', testTypeData.name);
							this.set('locationData', { from: 'World', probesCnt: this.get('totalProbesCnt') });
							this.set('highLevelLocationHref', `${global.location.origin}${this.modifyQueryPart(testTypeData.name, 'world')}`);
						} else {
							this.moveToNewPageURL(INITIAL_OPTS_VALUES.type, null, true);
						}
					}
				});
			}
		},
		proceedToTest () {
			let type = this.get('selectedTestType');
			let testOpts = this.get('testOpts');
			let { name: magic = 'World' } = this.get('locationData');
			let reqParams = {
				type,
				...testOpts,
				locations: [{ magic }],
			};

			if (!reqParams.limit) {
				reqParams.limit = DEFAULT_LIMIT;
			}

			// clear all data from the previous test, show spinner
			this.set('testResults', null);
			this.set('testInProgress', true);
			this.set('testReqParams', null);

			http.postGlobalpingMeasurement(reqParams).then((response) => {
				this.getTestMeasurementById(response.id);
			}).catch((err) => {
				if (err.error.type === 'validation_error') {
					this.set('testInProgress', false);

					let inputErrors = Object.keys(err.error.params).reduce((res, key) => {
						let fieldName = key.split('.')[key.split('.').length - 1];
						let errMsg = err.error.params[key].replace(/".*"/, fieldName);

						res[key] = errMsg;

						return res;
					}, {});

					this.set('inputErrors', inputErrors);
				}
			});
		},
		handleProbesResponse (isStored) {
			return (response) => {
				if (!isStored) {
					sessionStorage.setItem('probesResponse', JSON.stringify(response));
				} else {
					response = JSON.parse(response);
				}

				this.set('parsedLocations', this.parseProbesResponse(response));
				this.set('totalProbesCnt', response.length);
				this.set('probesParsed', true);
			};
		},
		parseProbesResponse (data) {
			return data.reduce((res, item) => {
				let cityNameLC = item.location.city.toLowerCase();
				let cityNameAsUrlPart = cityNameLC.split(' ').join('-');
				let countryCodeLC = item.location.country.toLowerCase();
				let countryNameLC = countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase();
				let countryNameAsUrlPart = countryNameLC.split(' ').join('-');
				let asnName = `as${item.location.asn}`;
				let networkNameAsKey = item.location.network.replace(/[^\w]|_/g, '').toLowerCase();
				let continentCodeLC = item.location.continent.toLowerCase();
				let continentNameLC = continents.find(i => i.code.toLowerCase() === continentCodeLC).name.toLowerCase();
				let continentNameAsUrlPart = continentNameLC.split(' ').join('-');
				let regionNameLC = item.location.region.toLowerCase();
				let stateCodeLC = item.location.state ? item.location.state.toLowerCase() : null;
				let stateNameLC = stateCodeLC ? usaStates.find(i => i.code.toLowerCase() === stateCodeLC).name.toLowerCase() : null;
				let stateNameAsUrlPart = stateNameLC ? stateNameLC.split(' ').join('-') : null;

				// collect uniques cities and count amount of probes per city
				if (!Object.keys(res.cities).includes(cityNameAsUrlPart)) {
					res.cities[cityNameAsUrlPart] = {
						name: cityNameLC,
						from: countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase(),
						probesCnt: 1,
						fromAsUrlPart: countryNameAsUrlPart,
					};
				} else {
					res.cities[cityNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques ASNs and count amount of probes per ASN
				if (!Object.keys(res.asns).includes(asnName)) {
					res.asns[asnName] = {
						name: asnName,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.asns[asnName].probesCnt += 1;
				}

				// collect uniques Networks and count amount of probes per Network
				if (!Object.keys(res.networks).includes(networkNameAsKey)) {
					res.networks[networkNameAsKey] = {
						name: item.location.network,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.networks[networkNameAsKey].probesCnt += 1;
				}

				// collect uniques Countries and count amount of probes per Country
				if (!Object.keys(res.countries).includes(countryNameAsUrlPart)) {
					res.countries[countryNameAsUrlPart] = {
						name: countryNameLC,
						from: continentNameLC,
						probesCnt: 1,
						fromAsUrlPart: continentNameAsUrlPart,
					};
				} else {
					res.countries[countryNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques Continents and count amount of probes per Continent
				if (!Object.keys(res.continents).includes(continentNameAsUrlPart)) {
					res.continents[continentNameAsUrlPart] = {
						name: continentNameLC,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.continents[continentNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques Regions and count amount of probes per Region
				if (!Object.keys(res.regions).includes(regionNameLC)) {
					res.regions[regionNameLC] = {
						name: regionNameLC,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.regions[regionNameLC].probesCnt += 1;
				}

				// collect uniques states (if they are present) and count amount of probes per state
				if (stateNameAsUrlPart) {
					if (!Object.keys(res.states).includes(stateNameAsUrlPart)) {
						res.states[stateNameAsUrlPart] = {
							name: stateNameLC,
							from: countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase(),
							probesCnt: 1,
							fromAsUrlPart: countryNameAsUrlPart,
						};
					} else {
						res.states[stateNameAsUrlPart].probesCnt += 1;
					}
				}

				return res;
			}, {
				cities: {},
				asns: {},
				networks: {},
				countries: {},
				continents: {},
				regions: {},
				states: {},
			});
		},
		getLocDataByLocValue (location) {
			let locationLC = location.toLowerCase();
			let parsedLocations = this.get('parsedLocations');
			let networkNameAsKey = locationLC.replace(/[^\w]|_/g, '');

			// check if the location is a city
			if (parsedLocations.cities[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.cities[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is an ASN
			if (parsedLocations.asns[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.asns[locationLC];

				return {
					name: name.toUpperCase(),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Network
			if (parsedLocations.networks[networkNameAsKey]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.networks[networkNameAsKey];

				return {
					name,
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Country
			if (parsedLocations.countries[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.countries[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from, [ 'and' ]),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Continent
			if (parsedLocations.continents[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.continents[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Region
			if (parsedLocations.regions[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.regions[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a State
			if (parsedLocations.states[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.states[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}
		},
		getTestMeasurementById (measurementId) {
			let testReqInterval = setInterval(() => {
				http.getGlobalpingMeasurement(measurementId).then((testRes) => {
					// prepare and set request params to pass them to gp-test-results
					let testReqParams = JSON.parse(JSON.stringify(testRes));

					delete testReqParams.results;
					delete testReqParams.status;
					delete testReqParams.updatedAt;
					delete testReqParams.createdAt;

					testReqParams = {
						inProgressUpdates: true,
						limit: DEFAULT_LIMIT,
						...testReqParams,
						measurementOptions: {
							trace: false,
							...testReqParams.measurementOptions,
						},
					};

					// set testReqParams to pass them to c-gp-test-results
					this.set('testReqParams', testReqParams);

					// should be after the mainOptions.type was set
					this.set('realTimeTestResResponse', testRes);
				}).catch(() => {
					clearInterval(testReqInterval);
				});
			}, 1000);

			this.set('testReqInterval', testReqInterval);
		},
		handleTestTypeSelect (testTypeName) {
			this.set('selectedTestType', testTypeName);
			this.moveToNewPageURL(testTypeName);
		},
		moveToNewPageURL (testType, newLocation = null, leaveTestOnly = false) {
			let newPath = this.modifyQueryPart(testType, newLocation, leaveTestOnly);

			app.router.dispatch(newPath, { noScroll: true });
		},
		modifyQueryPart (testType = 'ping', newLocation = null, leaveTestOnly = false) {
			let splittedQueryTestFrom = app.router.uri.path.split('/');
			let newQueryTestFromValue = '';

			if (newLocation) {
				newQueryTestFromValue = `${testType}-from-${newLocation}`;
			} else if (leaveTestOnly) {
				newQueryTestFromValue = testType;
			} else {
				let currQueryTestFromValue = splittedQueryTestFrom[splittedQueryTestFrom.length - 1];

				newQueryTestFromValue = currQueryTestFromValue.replace(/[A-Za-z]+/, `${testType}`);
			}

			let newPath = splittedQueryTestFrom.reduce((res, part, idx) => {
				return idx === splittedQueryTestFrom.length - 1 ? res : res += `${part}/`;
			}, '') + newQueryTestFromValue;

			return newPath.toLowerCase();
		},
	};
</script>
