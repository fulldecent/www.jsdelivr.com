<link rel="ractive" href="../../r-page-globalping.html" name="r-page">
<link rel="ractive" href="../../components/header.html" name="c-header">
<link rel="ractive" href="../../components/footer.html" name="c-footer">
<link rel="ractive" href="../../components/notification.html" name="c-notification">
<link rel="ractive" href="../../components/controlled-input.html" name="c-controlled-input">
<link rel="ractive" href="../../components/gp-test-results.html" name="c-gp-test-results">
<link rel="ractive" href="../../components/gp-jumbotron.html" name="c-gp-jumbotron">

<r-page noYield="{{noYield}}" title="{{title}}" description="{{description}}">
	<c-notification></c-notification>

	<c-header additionalClasses="header-with-globalping-bg"></c-header>

	<div class="p-globalping-network-tools">
		<div class="gp-nettools_main-info">
			<c-gp-jumbotron className="network-tools" useAltGridImg="true"></c-gp-jumbotron>

			<div class="gp-nettools_main-info_content">
				{{#if locationData}}
					<h1>{{displayingTestType}} from {{#if locationData.probesCnt}}multiple locations in {{/if}}</h1>
					<span>
						{{#if locationData.name}}{{locationData.name}}, {{/if}}
						<a target="_blank" rel="noopener noreferrer" href="{{highLevelLocationHref}}" class="gp-nettools_green-text">{{locationData.from}}</a>
					</span>

					<div class="gp-nettools_main-info_content_input-block">
						<span>Run a Free</span>

						<div class="gp_dropdown_alt">
							<div class="btn-group">
								<button type="button"
									class="dropdown-toggle"
									data-toggle="dropdown"
									aria-haspopup="true"
									aria-expanded="false">
									<span>{{~/displayingTestType}}</span>
									<i class="fa fa-angle-down" aria-hidden="true"></i>
								</button>

								<div class="dropdown-menu">
									{{#each ~/testTypesList}}
										{{#if this.toDisplay !== displayingTestType}}
											<div on-click="@this.handleTestTypeSelect(this.name)">{{this.toDisplay}}</div>
										{{/if}}
									{{/each}}
								</div>
							</div>
						</div>

						<span>test</span>
					</div>
				{{/if}}
			</div>
		</div>

		<div class="gp-nettools_demo-tools">
			<div class="gp-nettools_demo-tools_head">
				<span></span>
				<span></span>
				<span></span>
			</div>

			<div class="gp-nettools_demo-tools_ctrls">
				<c-controlled-input
					id="targetInput"
					value="{{testOpts.target}}"
					error="{{inputErrors.target}}"
					placeholder="IP or host"
					labelText="Target"
					classList="gp-nettools_demo-tools_ctrls_target gp_input">
				</c-controlled-input>

				<c-controlled-input
					id="limitInput"
					value="{{testOpts.limit}}"
					error="{{inputErrors.limit}}"
					placeholder="{{defaultTestLimit}}"
					labelText="Probes"
					classList="gp-nettools_demo-tools_ctrls_probes gp_input">
				</c-controlled-input>

				<button on-click="@this.proceedToTest()"
					class="gp-nettools_demo-tools_ctrls_btn gp_btn_green {{#if testInProgress}}gp_btn_green_disabled gp_btn_green_loading{{/if}}"
					disabled="{{testInProgress}}">
					{{#if testInProgress}}
						<div></div>
						<div></div>
						<div></div>
						<div></div>
					{{else}}
						Run {{btnTestType}} Test
					{{/if}}
				</button>
			</div>

			{{#if testFailed}}
				<div class="gp_map-block_demo-tools_fail-msg">
					<img width="56"
						height="56"
						src="{{@shared.assetsHost}}/img/globalping/fail-icon-big.svg">

					<p>
						All tests failed. Maybe you specified a non existing endpoint?
					</p>
				</div>
			{{elseif testResults}}
				<c-gp-test-results
					testReqParams="{{testReqParams}}"
					testResults="{{testResults}}"
					testInProgress="{{testInProgress}}">
				</c-gp-test-results>
			{{elseif locationData}}
				<div class="gp-nettools_demo-tools_descr">
					<img width="56"
						height="56"
						src="{{@shared.assetsHost}}/img/globalping/bulb-icon.svg">
					<span>
						Run a global ping test from {{locationData.name || locationData.from}} to debug and troubleshoot your network, CDN, or website.
						Use ping to measure your latency from {{locationData.name || locationData.from}}
					</span>
				</div>
			{{/if}}
		</div>

		<div class="gp-nettools_learn-how">
			{{#if locationData}}
				<span class="gp-nettools_learn-how_title">
					Explore how Globalping makes global network tests and benchmarking possible and free for all.
				</span>

				<span class="gp-nettools_learn-how_descr">
					Debug your web services and servers and understand and fix your routing by running network commands like ping from {{locationData.name || locationData.from}} or any other location like a country or city.
				</span>

				<a href="/globalping" class="gp-nettools_learn-how_btn gp_btn_green">
					Learn more
				</a>
			{{/if}}
		</div>

		<div class="gp-nettools_depiction">
			{{#if locationData}}
				<div class="gp-nettools_depiction_test">
					<span class="gp-nettools_depiction_test_header">
						What is ping?
					</span>

					<p class="gp-nettools_depiction_test_descr">
						Ping is a network testing and troubleshooting utility that helps identify problems when
						you can't reach a server or experience slow loading times. It's also often used for simple
						network performance monitoring, determining if a website is reachable from the local network, or resolving a hostname's IP address.
					</p>

					<p class="gp-nettools_depiction_test_descr">
						Ping sends Internet Control Message Protocol (ICMP) packets from your location to a target
						host (a hostname or IP address) to test connectivity. If everything goes well, the target
						receives the request and sends back a response to confirm that it's reachable and working.
						The response includes the round-trip time (RTT), which tells you how long it took for the
						data to travel to the destination and back. This RTT can also indicate the latency, or delay, to the target.
					</p>

					<span class="gp-nettools_depiction_test_header">
						What are everyday use cases for ping?
					</span>

					<p class="gp-nettools_depiction_test_descr">
						Not sure how ping can help you? Here are some popular use cases:
					</p>

					<span class="gp-nettools_depiction_test_subheader">
						Test network connectivity
					</span>
					<p class="gp-nettools_depiction_test_descr">
						Ping is the go-to tool when you experience network issues. By sending data packets to a target
						host and receiving a response, ping lets you quickly verify if the target is reachable and evaluate
						the overall network connectivity.
					</p>

					<span class="gp-nettools_depiction_test_subheader">
						Measure latency
					</span>
					<p class="gp-nettools_depiction_test_descr">
						You may have a network bottleneck or other performance issues if you spot unusually high RTTs in
						your ping results. If you notice high latency but don't know where in the network the problem is,
						pinging different hosts and comparing the RTTs helps find the problematic devices.
					</p>

					<span class="gp-nettools_depiction_test_subheader">
						Test website reachability
					</span>
					<p class="gp-nettools_depiction_test_descr">
						When you can't load a website via your browser, ping the website's hostname to check if it's reachable
						from your network. This lets you determine whether you're facing network-related issues or a problem with your browser.
					</p>

					<span class="gp-nettools_depiction_test_subheader">
						Diagnose Internet connection problems
					</span>
					<p class="gp-nettools_depiction_test_descr">
						Can't connect to the Internet? Ping your router's IP address to verify if your device can reach the
						router, helping you find out if the issue lies within your local network or the Internet connection.
					</p>

					<span class="gp-nettools_depiction_test_subheader">
						Monitor networks
					</span>
					<p class="gp-nettools_depiction_test_descr">
						Create automated scripts that regularly ping one or more hosts and store the result data. Use this
						data to identify hosts that frequently cause high response times, packet loss, or other problems so you can take action.
					</p>

					<span class="gp-nettools_depiction_test_header">
						What are common use cases to run ping from {{locationData.name || locationData.from}}?
					</span>

					<p class="gp-nettools_depiction_test_descr">
						Sometimes you need to run network tests from locations that aren't accessible to you. That's where Globalping comes
						to the rescue. It's a platform that relies on a globally distributed network of probes, allowing you to
						perform measurements from any corner of the world.
					</p>

					<p class="gp-nettools_depiction_test_descr">
						Running ping from {{locationData.name || locationData.from}} and other places provides many insights and extends the
						use cases we explored in the previous section:
					</p>

					<ul class="gp-nettools_depiction_test_descr">
						<li>Set up global network monitoring</li>
						<li>Test website availability from various regions</li>
						<li>Measure latency as experienced by users across the globe</li>
					</ul>

					<p class="gp-nettools_depiction_test_descr">
						Here are some additional use cases for geographically distributed ping:
					</p>

					<span class="gp-nettools_depiction_test_subheader">
						Optimize content delivery
					</span>
					<p class="gp-nettools_depiction_test_descr">
						Run ping from {{locationData.name || locationData.from}} and other locations to test the latency to your website or API. Examine the ping's
						RTTs - if they're unusually high, users likely experience delays and long loading times. To reduce latency,
						consider using a CDN (Content Delivery Network) for efficient content distribution.
					</p>

					<span class="gp-nettools_depiction_test_subheader">
						Troubleshoot from your users' perspective
					</span>
					<p class="gp-nettools_depiction_test_descr">
						Imagine your website users in {{locationData.name || locationData.from}} are reporting issues, but everything
						seems fine from your end. With Globalping, you can run ping from {{locationData.name || locationData.from}} as if you were doing it from your
						location to troubleshoot the problem.
					</p>

					<span class="gp-nettools_depiction_test_subheader">
						Monitor remote servers
					</span>
					<p class="gp-nettools_depiction_test_descr">
						If you manage servers around the globe, running ping from different locations can be of invaluable help for
						monitoring performance and connectivity. This allows you to respond faster and more informed when issues in specific regions arise.
					</p>
				</div>
			{{/if}}
		</div>
	</div>

	<c-footer></c-footer>
</r-page>

<script>
	const _ = require('../../../assets/js/_');
	const http = require('../../../assets/js/utils/http');
	const has = require('../../../assets/js/utils/has');
	const countries = require('../../../assets/json/countries.json');
	const continents = require('../../../assets/json/continents.json');
	const usaStates = require('../../../assets/json/usa-states.json');
	const DEFAULT_LIMIT = 3;
	const INITIAL_OPTS_VALUES = {
		type: 'Ping',
		target: 'cdn.jsdelivr.net',
	};

	component.exports = {
		data () {
			return {
				_,
				title: 'Globalping - jsDelivr',
				description: 'TODO: add Globalping Network Tools description',
				selectedTestType: INITIAL_OPTS_VALUES.type,
				displayingTestType: INITIAL_OPTS_VALUES.type,
				btnTestType: INITIAL_OPTS_VALUES.type,
				testTypesList: [
					{
						name: 'Ping',
						toDisplay: 'Ping',
					},
					{
						name: 'Traceroute',
						toDisplay: 'Traceroute',
					},
					{
						name: 'DNS',
						toDisplay: 'DNS resolve',
					},
					{
						name: 'MTR',
						toDisplay: 'MTR',
					},
					{
						name: 'HTTP',
						toDisplay: 'HTTP',
					},
				],
				testOpts: {
					target: INITIAL_OPTS_VALUES.target,
					limit: '',
				},
				inputErrors: {},
				testResults: null,
				testInProgress: false,
				testReqInterval: null,
				defaultTestLimit: DEFAULT_LIMIT,
				probesResponse: null,
				locationData: null,
				totalProbesCnt: 0,
				parsedLocations: {
					cities: {},
					asns: {},
					networks: {},
					countries: {},
					continents: {},
					regions: {},
				},
				highLevelLocationHref: null,
				probesParsed: false,
				testReqParams: null,
				clearParamsValue: null,
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				this.getGlobalpingProbesData();

				this.getParamsFromUrl();

				this.observe('selectedTestType', (selectedTestType) => {
					if (selectedTestType) {
						switch (selectedTestType.toLowerCase()) {
							case 'mtr':
							case 'http':
								this.set('displayingTestType', selectedTestType.toUpperCase());
								this.set('btnTestType', selectedTestType.toUpperCase());

								break;

							case 'dns':
								this.set('displayingTestType', `${selectedTestType.toUpperCase()} resolve`);
								this.set('btnTestType', selectedTestType.toUpperCase());

								break;

							default:
								this.set('displayingTestType', _.capitalizeStrEveryFirstLetter(selectedTestType));
								this.set('btnTestType', _.capitalizeStrEveryFirstLetter(selectedTestType));
						}
					}

					this.set('inputErrors', {});
					this.set('testResults', null);
				});

				this.observe('realTimeTestResResponse', (realTimeTestResResponse) => {
					if (realTimeTestResResponse.status === 'finished') {
						clearInterval(this.get('testReqInterval'));
						this.set('testInProgress', false);
					}

					let prevTestResults = this.get('testResults') || [];
					let updTestResults = realTimeTestResResponse.results.filter((res) => {
						// if it is no in-progress then it is already finished or failed and we could draw a marker
						if (res.result.status !== 'in-progress') { return true; }

						return false;
					});

					// filter out results that have already been drawn
					let newTestResults = updTestResults.filter((updRes) => {
						return !prevTestResults.some(prevRes => JSON.stringify(prevRes) === JSON.stringify(updRes));
					});

					this.set('testResults', [ ...prevTestResults, ...newTestResults ]);
				}, { init: false });
			}
		},
		oncomplete () {
			if (!Ractive.isServer) {
				// run the test if user is pressed Enter inside of any of options inputs
				let targetInput = this.find('#targetInput');
				let limitInput = this.find('#limitInput');

				let handleEnterBtn = (event) => {
					if (event.key === 'Enter') {
						event.preventDefault();
						this.proceedToTest();
					}
				};

				targetInput.addEventListener('keypress', handleEnterBtn);
				limitInput.addEventListener('keypress', handleEnterBtn);

				// handle URL, get values from it and set locationData
				this.observe('probesParsed', (probesParsed) => {
					if (!probesParsed) { return; }

					let clearParamsValue = this.get('clearParamsValue');
					let testTypesList = this.get('testTypesList');

					if (clearParamsValue.includes('-from-')) {
						let paramsValueSplitted = clearParamsValue.split('-from-');
						let testType = paramsValueSplitted[0];
						let locationData = this.getLocDataByLocValue(paramsValueSplitted[1]);
						let isTestTypePresents = testTypesList.some(i => i.name.toLowerCase() === testType.toLowerCase());

						// if both location and testType are correct and present
						if (locationData && isTestTypePresents) {
							this.set('selectedTestType', testType);
							this.set('locationData', locationData);
							this.set('highLevelLocationHref', `${global.location.origin}${this.modifyQueryPart(testType, locationData.fromAsUrlPart)}`);
						} else if (isTestTypePresents && !locationData) {
						// when testType correct but location incorrect or missing
							this.moveToNewPageURL(testType, null, true);
						} else if (locationData && !isTestTypePresents) {
						// when  location correct and testType is incorrect
							this.moveToNewPageURL(INITIAL_OPTS_VALUES.type);
						} else {
							// when testType is incorect and location incorrect or missing
							this.moveToNewPageURL(INITIAL_OPTS_VALUES.type, null, true);
						}
					} else {
						let testTypeData = testTypesList.find(i => i.name.toLowerCase() === clearParamsValue);

						if (testTypeData) {
							this.set('selectedTestType', testTypeData.name);
							this.set('locationData', { from: 'World', probesCnt: this.get('totalProbesCnt') });
							this.set('highLevelLocationHref', `${global.location.origin}${this.modifyQueryPart(testTypeData.name, 'world')}`);
						} else {
							this.moveToNewPageURL(INITIAL_OPTS_VALUES.type, null, true);
						}
					}
				});
			}
		},
		proceedToTest () {
			let type = this.get('selectedTestType');
			let testOpts = this.get('testOpts');
			let { name: magic = 'World' } = this.get('locationData');
			let reqParams = {
				type,
				...testOpts,
				locations: [{ magic }],
			};

			if (!reqParams.limit) {
				reqParams.limit = DEFAULT_LIMIT;
			}

			// clear all data from the previous test, show spinner
			this.set('testResults', null);
			this.set('testInProgress', true);
			this.set('testReqParams', null);

			http.postGlobalpingMeasurement(reqParams).then((response) => {
				this.getTestMeasurementById(response.id);
			}).catch((err) => {
				if (err.error.type === 'validation_error') {
					this.set('testInProgress', false);

					let inputErrors = Object.keys(err.error.params).reduce((res, key) => {
						let fieldName = key.split('.')[key.split('.').length - 1];
						let errMsg = err.error.params[key].replace(/".*"/, fieldName);

						res[key] = errMsg;

						return res;
					}, {});

					this.set('inputErrors', inputErrors);
				}
			});
		},
		handleProbesResponse (isStored) {
			return (response) => {
				if (!isStored) {
					sessionStorage.setItem('probesResponse', JSON.stringify(response));
				} else {
					response = JSON.parse(response);
				}

				this.set('parsedLocations', this.parseProbesResponse(response));
				this.set('totalProbesCnt', response.length);
				this.set('probesParsed', true);
			};
		},
		parseProbesResponse (data) {
			return data.reduce((res, { location }) => {
				let cityNameLC = location.city.toLowerCase();
				let cityNameAsUrlPart = cityNameLC.split(' ').join('-');
				let countryCodeLC = location.country.toLowerCase();
				let countryNameLC = countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase();
				let countryNameAsUrlPart = countryNameLC.split(' ').join('-');
				let asnName = `as${location.asn}`;
				let networkNameAsKey = location.network.replace(/\./g, '').replace(/[\W]|_/g, ' ').replace(/\s\s+|_/g, ' ').trim().split(' ').join('-').toLowerCase();
				let continentCodeLC = location.continent.toLowerCase();
				let continentNameLC = continents.find(i => i.code.toLowerCase() === continentCodeLC).name.toLowerCase();
				let continentNameAsUrlPart = continentNameLC.split(' ').join('-');
				let regionNameLC = location.region.toLowerCase();
				let stateCodeLC = location.state ? location.state.toLowerCase() : null;
				let stateNameLC = stateCodeLC ? usaStates.find(i => i.code.toLowerCase() === stateCodeLC).name.toLowerCase() : null;
				let stateNameAsUrlPart = stateNameLC ? stateNameLC.split(' ').join('-') : null;

				// collect uniques cities and count amount of probes per city
				if (!Object.keys(res.cities).includes(cityNameAsUrlPart)) {
					res.cities[cityNameAsUrlPart] = {
						name: cityNameLC,
						from: countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase(),
						probesCnt: 1,
						fromAsUrlPart: countryNameAsUrlPart,
					};
				} else {
					res.cities[cityNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques ASNs and count amount of probes per ASN
				if (!Object.keys(res.asns).includes(asnName)) {
					res.asns[asnName] = {
						name: asnName,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.asns[asnName].probesCnt += 1;
				}

				// collect uniques Networks and count amount of probes per Network
				if (!Object.keys(res.networks).includes(networkNameAsKey)) {
					res.networks[networkNameAsKey] = {
						name: location.network,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.networks[networkNameAsKey].probesCnt += 1;
				}

				// collect uniques Countries and count amount of probes per Country
				if (!Object.keys(res.countries).includes(countryNameAsUrlPart)) {
					res.countries[countryNameAsUrlPart] = {
						name: countryNameLC,
						from: continentNameLC,
						probesCnt: 1,
						fromAsUrlPart: continentNameAsUrlPart,
					};
				} else {
					res.countries[countryNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques Continents and count amount of probes per Continent
				if (!Object.keys(res.continents).includes(continentNameAsUrlPart)) {
					res.continents[continentNameAsUrlPart] = {
						name: continentNameLC,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.continents[continentNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques Regions and count amount of probes per Region
				if (!Object.keys(res.regions).includes(regionNameLC)) {
					res.regions[regionNameLC] = {
						name: regionNameLC,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.regions[regionNameLC].probesCnt += 1;
				}

				// collect uniques states (if they are present) and count amount of probes per state
				if (stateNameAsUrlPart) {
					if (!Object.keys(res.states).includes(stateNameAsUrlPart)) {
						res.states[stateNameAsUrlPart] = {
							name: stateNameLC,
							from: countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase(),
							probesCnt: 1,
							fromAsUrlPart: countryNameAsUrlPart,
						};
					} else {
						res.states[stateNameAsUrlPart].probesCnt += 1;
					}
				}

				return res;
			}, {
				cities: {},
				asns: {},
				networks: {},
				countries: {},
				continents: {},
				regions: {},
				states: {},
			});
		},
		getLocDataByLocValue (location) {
			let locationLC = location.toLowerCase();
			let parsedLocations = this.get('parsedLocations');
			let networkNameAsKey = locationLC.replace(/\./g, '').replace(/[\W]|_/g, ' ').replace(/\s\s+|_/g, ' ').trim().split(' ').join('-').toLowerCase();

			// check if the location is a city
			if (parsedLocations.cities[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.cities[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is an ASN
			if (parsedLocations.asns[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.asns[locationLC];

				return {
					name: name.toUpperCase(),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Network
			if (parsedLocations.networks[networkNameAsKey]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.networks[networkNameAsKey];

				return {
					name,
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Country
			if (parsedLocations.countries[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.countries[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from, [ 'and' ]),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Continent
			if (parsedLocations.continents[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.continents[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Region
			if (parsedLocations.regions[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.regions[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a State
			if (parsedLocations.states[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.states[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}
		},
		getTestMeasurementById (measurementId) {
			let testReqInterval = setInterval(() => {
				http.getGlobalpingMeasurement(measurementId).then((testRes) => {
					// prepare and set request params to pass them to gp-test-results
					let testReqParams = JSON.parse(JSON.stringify(testRes));

					delete testReqParams.results;
					delete testReqParams.status;
					delete testReqParams.updatedAt;
					delete testReqParams.createdAt;

					testReqParams = {
						inProgressUpdates: true,
						limit: DEFAULT_LIMIT,
						...testReqParams,
						measurementOptions: {
							trace: false,
							...testReqParams.measurementOptions,
						},
					};

					// set testReqParams to pass them to c-gp-test-results
					this.set('testReqParams', testReqParams);

					// should be after the mainOptions.type was set
					this.set('realTimeTestResResponse', testRes);
				}).catch(() => {
					clearInterval(testReqInterval);
				});
			}, 1000);

			this.set('testReqInterval', testReqInterval);
		},
		handleTestTypeSelect (testTypeName) {
			this.set('selectedTestType', testTypeName);
			this.moveToNewPageURL(testTypeName);
		},
		moveToNewPageURL (testType, newLocation = null, leaveTestOnly = false) {
			let newPath = this.modifyQueryPart(testType, newLocation, leaveTestOnly);

			app.router.dispatch(newPath, { noScroll: true });
		},
		modifyQueryPart (testType = 'ping', newLocation = null, leaveTestOnly = false) {
			let newQueryTestFromValue = '';

			if (newLocation) {
				newQueryTestFromValue = `${testType}-from-${newLocation}`;
			} else if (leaveTestOnly) {
				newQueryTestFromValue = testType;
			} else {
				let splittedQueryTestFrom = app.router.uri.path.split('/');
				let currQueryTestFromValue = splittedQueryTestFrom[splittedQueryTestFrom.length - 1];

				newQueryTestFromValue = currQueryTestFromValue.replace(/[A-Za-z]+/, `${testType}`);
			}

			return `/globalping/network-tools/${newQueryTestFromValue.toLowerCase()}`;
		},
		getGlobalpingProbesData () {
			// get probes from sessionStorage or fetch them
			if (has.sessionStorage()) {
				let probesResponse = sessionStorage.getItem('probesResponse');

				if (probesResponse) {
					this.handleProbesResponse(true)(probesResponse);
				} else {
					http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
				}
			} else {
				http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
			}
		},
		getParamsFromUrl () {
			let rawParamsValue = this.get('params');

			if (rawParamsValue === null || typeof rawParamsValue === 'undefined') {
				this.moveToNewPageURL(INITIAL_OPTS_VALUES.type, null, true);

				return;
			}

			let clearParamsValue = rawParamsValue.replace(/\/globalping\/network-tools\/?/, '').toLowerCase();

			this.set('clearParamsValue', clearParamsValue);
		},
	};
</script>
