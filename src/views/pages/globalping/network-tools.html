<link rel="ractive" href="../../r-page-globalping.html" name="r-page">
<link rel="ractive" href="../../components/header.html" name="c-header">
<link rel="ractive" href="../../components/footer.html" name="c-footer">
<link rel="ractive" href="../../components/notification.html" name="c-notification">
<link rel="ractive" href="../../components/controlled-input.html" name="c-controlled-input">
<link rel="ractive" href="../../components/gp-test-results.html" name="c-gp-test-results">
<link rel="ractive" href="../../components/gp-top-navigation.html" name="c-gp-top-navigation">
<link rel="ractive" href="../../components/gp-jumbotron.html" name="c-gp-jumbotron">

<r-page noYield="{{noYield}}" title="{{title}}" description="{{description}}">
	<c-notification></c-notification>

	<c-header additionalClasses="header-with-globalping-bg"></c-header>

	<div class="p-globalping-network-tools">
		<c-gp-top-navigation currentName="globalping-network-tools"></c-gp-top-navigation>

		<c-gp-jumbotron className="network-tools" useAltGridImg="true"></c-gp-jumbotron>

		<div class="gp-nettools_main-info">
			{{#if locationData}}
				<h1>{{capitalizedTestType}} from {{#if locationData.probesCnt}}multiple locations in {{/if}}</h1>
				<span>
					{{#if locationData.name}}{{locationData.name}}, {{/if}}
					<a target="_blank" rel="noopener noreferrer" href="{{highLevelLocationHref}}" class="gp-nettools_green-text">{{locationData.from}}</a>
				</span>

				<div class="gp-nettools_main-info_input-block">
					<span>Run a Free</span>

					<div class="gp_dropdown_alt">
						<div class="btn-group">
							<button type="button"
								class="dropdown-toggle"
								data-toggle="dropdown"
								aria-haspopup="true"
								aria-expanded="false">
								<span>{{~/capitalizedTestType}}</span>
								<i class="fa fa-angle-down" aria-hidden="true"></i>
							</button>

							<div class="dropdown-menu">
								{{#each ~/testTypesList}}
									{{#if this !== capitalizedTestType}}
										<div on-click="@this.handleTestTypeSelect(this)">{{this}}</div>
									{{/if}}
								{{/each}}
							</div>
						</div>
					</div>

					<span>test</span>
				</div>
			{{/if}}
		</div>

		<div class="gp-nettools_demo-tools">
			<div class="gp-nettools_demo-tools_head">
				<span></span>
				<span></span>
				<span></span>
			</div>

			<div class="gp-nettools_demo-tools_ctrls">
				<c-controlled-input
					id="targetInput"
					value="{{testOpts.target}}"
					error="{{inputErrors.target}}"
					placeholder="IP or host"
					labelText="Target"
					classList="gp-nettools_demo-tools_ctrls_target gp_input">
				</c-controlled-input>

				<c-controlled-input
					id="limitInput"
					value="{{testOpts.limit}}"
					error="{{inputErrors.limit}}"
					placeholder="{{defaultProbesAmount}}"
					labelText="Probes"
					classList="gp-nettools_demo-tools_ctrls_probes gp_input">
				</c-controlled-input>

				<button on-click="@this.proceedToTest()"
					class="gp-nettools_demo-tools_ctrls_btn gp_btn_green {{#if testInProgress}}gp_btn_green_disabled gp_btn_green_loading{{/if}}"
					disabled="{{testInProgress}}">
					{{#if testInProgress}}
						<div></div>
						<div></div>
						<div></div>
						<div></div>
					{{else}}
						Run {{capitalizedTestType}} Test
					{{/if}}
				</button>
			</div>

			{{#if testFailed}}
				<div class="gp_map-block_demo-tools_fail-msg">
					<img width="56"
						height="56"
						src="{{@shared.assetsHost}}/img/globalping/fail-icon-big.svg">

					<p>
						All tests failed. Maybe you specified a non existing endpoint?
					</p>
				</div>
			{{elseif testResults}}
				<c-gp-test-results
					testType="{{selectedTestType}}"
					testResultsId="{{testResultsId}}"
					testResults="{{testResults}}"
					dnsTraceEnabled="{{false}}">
				</c-gp-test-results>
			{{else}}
				<div class="gp-nettools_demo-tools_descr">
					<img width="56"
						height="56"
						src="{{@shared.assetsHost}}/img/globalping/bulb-icon.svg">
					<span>Run a global ping latency test to debug and troubleshoot your network, CDN or website from multiple locations in Europe.</span>
				</div>
			{{/if}}
		</div>

		<div class="gp-nettools_learn-how">
			<span class="gp-nettools_learn-how_title">
				Learn more about how Globalping makes global network tests and benchmarking possible and free for all.
			</span>

			<span class="gp-nettools_learn-how_descr">
				Debug your web services and servers, understand and fix your routing, simply by running network commands from Europe or any other specific location like a country or city.
			</span>

			<a href="/globalping" class="gp-nettools_learn-how_btn gp_btn_green">
				Learn more
			</a>
		</div>

		<div class="gp-nettools_ping">
			<span class="gp-nettools_ping_title">
				What is ping?
			</span>

			<span class="gp-nettools_ping_descr">
				Ping is a tool that sends ICMP packets to an IP address (hostname is also accepted but will be first resolved to an IP) to understand the latency to the target or if the target server or website exist and are working. Since website and server response times are very important, Ping is a very simple way to quickly and easily check and understand the network delay in milliseconds between the sender and receiver. It's basically how long it takes for  data to travel across the internet to the destination and then back to the sender.  A low latency is always better and will result in a faster website and fewer issues. Methods to improve the latency include moving the server closer to the users, using a CDN or for advanced users improving peering and BGP routing.
			</span>
		</div>
	</div>

	<c-footer></c-footer>
</r-page>

<script>
	const _ = require('../../../assets/js/_');
	const http = require('../../../assets/js/utils/http');
	const has = require('../../../assets/js/utils/has');
	const countries = require('../../../assets/json/countries.json');
	const continents = require('../../../assets/json/continents.json');
	const DEFAULT_PROBES_AMOUNT = 3;
	const INITIAL_OPTS_VALUES = {
		type: 'Ping',
		target: 'cdn.jsdelivr.net',
	};

	component.exports = {
		data () {
			return {
				_,
				title: 'Globalping - jsDelivr',
				description: 'TODO: add Globalping Network Tools description',
				selectedTestType: INITIAL_OPTS_VALUES.type,
				capitalizedTestType: INITIAL_OPTS_VALUES.type,
				testTypesList: [ 'Ping', 'Traceroute', 'DNS', 'MTR', 'HTTP' ],
				testOpts: {
					target: INITIAL_OPTS_VALUES.target,
					limit: '',
				},
				inputErrors: {},
				testResultsId: null,
				testResults: null,
				testInProgress: false,
				testReqInterval: null,
				defaultProbesAmount: DEFAULT_PROBES_AMOUNT,
				probesResponse: null,
				locationData: null,
				totalProbesCnt: 0,
				parsedLocations: {
					cities: {},
					asns: {},
					networks: {},
					countries: {},
					continents: {},
					regions: {},
				},
				highLevelLocationHref: null,
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				this.observe('selectedTestType', (selectedTestType) => {
					if (selectedTestType) {
						switch (selectedTestType.toLowerCase()) {
							case 'dns':
							case 'mtr':
							case 'http':
								this.set('capitalizedTestType', selectedTestType.toUpperCase()); break;
							default:
								this.set('capitalizedTestType', _.capitalizeStrEveryFirstLetter(selectedTestType));
						}
					}

					this.set('inputErrors', {});
					this.set('testResultsId', null);
					this.set('testResults', null);
				});

				// get probes from sessionStorage or fetch them
				if (has.sessionStorage()) {
					let probesResponse = sessionStorage.getItem('probesResponse');

					if (probesResponse) {
						this.handleProbesResponse(true)(probesResponse);
					} else {
						http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
					}
				} else {
					http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
				}

				// handle URL, get values from it and set
				this.observe('params totalProbesCnt', () => {
					let rawParamsValue = this.get('params');
					let totalProbesCnt = this.get('totalProbesCnt');

					// check if totalProbesCnt already set - means that we already have parsedLocations
					if (!rawParamsValue || !totalProbesCnt) { return; }

					let clearValue = rawParamsValue.replace(/\/globalping\/network-tools\/?/, '').toLowerCase();

					if (clearValue.includes('-from-')) {
						let valueSplitted = clearValue.split('-from-');
						let testType = valueSplitted[0];
						let locationData = this.getLocationData(valueSplitted[1]);
						console.log("++++ locationData", locationData);
						console.log("++++ valueSplitted", valueSplitted);
						console.log("____________________");

						this.set('selectedTestType', testType);
						this.set('locationData', locationData);
						this.set('highLevelLocationHref', `${global.location.origin}${this.modifyQueryPart(testType, locationData.fromAsUrlPart)}`);
					} else {
						let testTypesList = this.get('testTypesList');
						let testType = testTypesList.find(i => i.toLowerCase() === clearValue);

						if (testType) {
							this.set('selectedTestType', testType);
						}

						this.set('locationData', { name: '', from: 'World', probesCnt: totalProbesCnt });
						this.set('highLevelLocationHref', `${global.location.origin}${this.modifyQueryPart(testType, 'world')}`);
					}
				});

				// handle test results in real time
				this.observe('realTimeTestResResponse', (realTimeTestResResponse) => {
					if (realTimeTestResResponse.status === 'finished') {
						clearInterval(this.get('testReqInterval'));
						this.set('testInProgress', false);
						this.set('testResultsId', realTimeTestResResponse.id);
					}

					let prevTestResults = this.get('testResults') || [];
					let updTestResults = realTimeTestResResponse.results.filter((res) => {
						// if it is no in-progress then it is already finished or failed and we could draw a marker
						if (res.result.status !== 'in-progress') { return true; }

						return false;
					});

					// filter out results that have already been drawn
					let newTestResults = updTestResults.filter((updRes) => {
						return !prevTestResults.some(prevRes => JSON.stringify(prevRes) === JSON.stringify(updRes));
					});

					this.set('testResults', [ ...prevTestResults, ...newTestResults ]);
				}, { init: false });
			}
		},
		oncomplete () {
			if (!Ractive.isServer) {
				// run the test if user is pressed Enter inside of any of options inputs
				let targetInput = this.find('#targetInput');
				let limitInput = this.find('#limitInput');

				let handleEnterBtn = (event) => {
					if (event.key === 'Enter') {
						event.preventDefault();
						this.proceedToTest();
					}
				};

				targetInput.addEventListener('keypress', handleEnterBtn);
				limitInput.addEventListener('keypress', handleEnterBtn);
			}
		},
		proceedToTest () {
			let type = this.get('selectedTestType');
			let testOpts = this.get('testOpts');
			let { name: magic = 'World' } = this.get('locationData');
			let reqParams = {
				type,
				...testOpts,
				locations: [{ magic }],
			};

			if (!reqParams.limit) {
				reqParams.limit = DEFAULT_PROBES_AMOUNT;
			}

			this.set('testResultsId', null);
			this.set('testResults', null);
			this.set('testInProgress', true);

			// get test interval and clear it when new test is started
			let testReqInterval = this.get('testReqInterval');

			if (testReqInterval) {
				clearInterval(testReqInterval);
			}

			http.postGlobalpingMeasurement(reqParams).then((response) => {
				this.getTestMeasurementById(response.id);
			}).catch((err) => {
				if (err.error.type === 'validation_error') {
					this.set('testInProgress', false);

					let inputErrors = Object.keys(err.error.params).reduce((res, key) => {
						let fieldName = key.split('.')[key.split('.').length - 1];
						let errMsg = err.error.params[key].replace(/".*"/, fieldName);

						res[key] = errMsg;

						return res;
					}, {});

					this.set('inputErrors', inputErrors);
				}
			});
		},
		handleProbesResponse (isStored) {
			return (response) => {
				if (!isStored) {
					sessionStorage.setItem('probesResponse', JSON.stringify(response));
				} else {
					response = JSON.parse(response);
				}

				this.parseProbesResponse(response);
			};
		},
		parseProbesResponse (data) {
			let parsedLocations = data.reduce((res, item) => {
				let cityNameLC = item.location.city.toLowerCase();
				let cityNameAsUrlPart = cityNameLC.split(' ').join('-');
				let countryCodeLC = item.location.country.toLowerCase();
				let countryNameLC = countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase();
				let countryNameAsUrlPart = countryNameLC.split(' ').join('-');
				let asnName = `as${item.location.asn}`;
				let networkNameAsKey = item.location.network.replace(/[^\w]|_/g, '').toLowerCase();
				let continentCodeLC = item.location.continent.toLowerCase();
				let continentNameLC = continents.find(i => i.code.toLowerCase() === continentCodeLC).name.toLowerCase();
				let continentNameAsUrlPart = continentNameLC.split(' ').join('-');
				let regionNameLC = item.location.region.toLowerCase();

				// collect uniques cities and count amount of probes per city
				if (!Object.keys(res.cities).includes(cityNameAsUrlPart)) {
					res.cities[cityNameAsUrlPart] = {
						name: cityNameLC,
						from: countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase(),
						probesCnt: 1,
						fromAsUrlPart: countryNameAsUrlPart,
					};
				} else {
					res.cities[cityNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques ASNs and count amount of probes per ASN
				if (!Object.keys(res.asns).includes(asnName)) {
					res.asns[asnName] = {
						name: asnName,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.asns[asnName].probesCnt += 1;
				}

				// collect uniques Networks and count amount of probes per Network
				if (!Object.keys(res.networks).includes(networkNameAsKey)) {
					res.networks[networkNameAsKey] = {
						name: item.location.network,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.networks[networkNameAsKey].probesCnt += 1;
				}

				// collect uniques Countries and count amount of probes per Country
				if (!Object.keys(res.countries).includes(countryNameAsUrlPart)) {
					res.countries[countryNameAsUrlPart] = {
						name: countryNameLC,
						from: continentNameLC,
						probesCnt: 1,
						fromAsUrlPart: continentNameAsUrlPart,
					};
				} else {
					res.countries[countryNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques Continents and count amount of probes per Continent
				if (!Object.keys(res.continents).includes(continentNameAsUrlPart)) {
					res.continents[continentNameAsUrlPart] = {
						name: continentNameLC,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.continents[continentNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques Regions and count amount of probes per Region
				if (!Object.keys(res.regions).includes(regionNameLC)) {
					res.regions[regionNameLC] = {
						name: regionNameLC,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.regions[regionNameLC].probesCnt += 1;
				}

				return res;
			}, {
				cities: {},
				asns: {},
				networks: {},
				countries: {},
				continents: {},
				regions: {},
			});

			// set parsedLocations before totalProbesCnt, important for the params observer logic
			this.set('parsedLocations', parsedLocations);
			this.set('totalProbesCnt', data.length);
		},
		getLocationData (location) {
			let locationLC = location.toLowerCase();
			let parsedLocations = this.get('parsedLocations');
			let networkNameAsKey = locationLC.replace(/[^\w]|_/g, '');

			// check if the location is a city
			if (parsedLocations.cities[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.cities[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is an ASN
			if (parsedLocations.asns[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.asns[locationLC];

				return {
					name: name.toUpperCase(),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Network
			if (parsedLocations.networks[networkNameAsKey]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.networks[networkNameAsKey];

				return {
					name,
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Country
			if (parsedLocations.countries[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.countries[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from, [ 'and' ]),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Continent
			if (parsedLocations.continents[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.continents[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// check if the location is a Region
			if (parsedLocations.regions[locationLC]) {
				let { name, from, probesCnt, fromAsUrlPart } = parsedLocations.regions[locationLC];

				return {
					name: _.capitalizeStrEveryFirstLetter(name),
					from: _.capitalizeStrEveryFirstLetter(from),
					probesCnt,
					fromAsUrlPart,
				};
			}

			// if couldnt be identified as ASN, Network, city etc. then we should show defaults
			return {
				name: null,
				from: 'World',
				probesCnt: this.get('totalProbesCnt'),
				fromAsUrlPart: 'world',
			};
		},
		getTestMeasurementById (measurementId) {
			let testReqInterval = setInterval(() => {
				http.getGlobalpingMeasurement(measurementId).then((testRes) => {
					// needed for c-gp-test-results calcs
					this.set('dnsTraceEnabled', testRes.measurementOptions?.trace || false);

					// should be after the mainOptions.type was set
					this.set('realTimeTestResResponse', testRes);
				}).catch(() => {
					clearInterval(testReqInterval);
				});
			}, 1000);

			this.set('testReqInterval', testReqInterval);
		},
		handleTestTypeSelect (testType) {
			this.set('selectedTestType', testType);
			this.moveToNewPageURL(testType);
		},
		moveToNewPageURL (testType) {
			let newPath = this.modifyQueryPart(testType);

			app.router.dispatch(newPath, { noScroll: true });
		},
		modifyQueryPart (testType = 'ping', location = null) {
			let splittedQueryTestFrom = app.router.uri.path.split('/');
			let newQueryTestFromValue = '';

			if (location) {
				newQueryTestFromValue = `${testType}-from-${location}`;
			} else {
				let currQueryTestFromValue = splittedQueryTestFrom[splittedQueryTestFrom.length - 1];

				newQueryTestFromValue = currQueryTestFromValue.replace(/[A-Za-z]+/, `${testType}`);
			}

			let newPath = splittedQueryTestFrom.reduce((res, part, idx) => {
				return idx === splittedQueryTestFrom.length - 1 ? res : res += `${part}/`;
			}, '') + newQueryTestFromValue;

			return newPath.toLowerCase();
		},
	};
</script>
